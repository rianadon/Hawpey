Each device has two modes of operation: a websocket for monitoring and a RESTful API for controlling and modifying.

Properties
----------
Each device has the following properties:
* Variables
	* These can be modified by the user to change the operation of the device.
	These should not be changed often but rather be considered as settings (e.g. whether to use inches or centimeters).
* Controls
	* Each device can have a number of controls that can trigger actions within the device.
	For example, a control could be used to turn a light on and off.
* Outputs
	* Outputs display the information a device collects from the outside world.

	The current state of a control is also considered an output (except in the `hawpey-util` library). The name of the control and its matching output must be identical.
* Program
	* Each device runs a modifiable program spawned by the server that populates outputs and handles the state changes of controls.
* Format
	* The format is a JSON file specifying how a device's outputs should be visually displayed.
* Logs
	* Logs are populated by the program and can be used for debugging. The server also logs HTTP requests.
* Timers
	* Timers are just `setInterval` functions created by the program. These can be manually triggerd via the RESTful API.
* Charts
	* Programs can populate charts to show trends in outputs over time.

Every property except the program, the logs, and the charts has both a name and a value.

The Websocket
-------------
Every device has a websocket at the path `/ws` on port `2000`. Through the websocket, JSON "packets" are sent by the master (to request certain information) and by the device (to relay information when requested or changed).

When an unexpected error occurs in the program of the device, it should send an error to the master, which then handles it.
Errors are automatically sent when an exception in thrown in the program, but ideally it should be caught in the program so that it can send more helpful information.

Listed below is the structure for requests and updates.

#### Requests (master → device)
```javascript
{
	"type": "request",
	"filter": ".*" // Optional
}
```
`filter` is a regex string that can be used to limit the controls sent back.
Any control whose name matches the regex is relayed back.
As it is optional, it defaults to `.*`.

#### Updates (device → master)
```javascript
{
	"type": "update",
	"outputs": {
		[name]: {
			"value": true, // An example
			"units": "" // Optional
		]
		// ...
	}
}
```
`name` specifies the name of the output. It is used by the webpage to later identify it

`value` can be of the data types `number`, `boolean`, or `string`. Use common sense for the type you will give it. Here are some guidelines:

|        Data       |   Type  |
|-------------------|---------|
| 4, 16 in, 12%     | number  |
| On, off           | boolean |
| Loading, abnormal | string  |

`units` is an optional string that is appended to `value`. If there should be a space between the units and the value, then `units` should begin with a space.
The styling is up to you to decide.

#### Errors (device → master)
```javascript
{
	"type": "error",
	"title": "Error", // An example
	"description": "There has been an error", // Another example
	"reason": "", // Optional
	"resolution": "" // Optional
}
```

`title` specifies a brief description of the error that has occurred. It should be no more than 70-75 characters.

`description` is a longer description of the error. It can be as long as desired.

`reason` is an optional string that gives the user a reason why the error occurred.

`resolution` is another optional string that gives the user an idea of how to fix the error so it is not thrown again.

#### Logs (device → master)
```javascript
{
	"type": "log",
	"record": {
		"name": "hawpey",
		"hostname": "something", // An example
		"pid": 50346, // Another example
		"level": 30, // Example
		"v": 0,
		"time": "2012-06-19T21:34:19.906Z" // Example
		"area": "program" // Another example
		"msg": "hello world" // Example
	}
}
```

As Hawpey internally uses Bunayan for logging, the value of `record` is whatever it outputs.

The only special field generated by hapwey is `area`, which represents whether the message came from the server (`server`), the program (`program`), or the main server program (`main`).

#### Charts (device → master)
```javascript
{
	"type": "plot",
	"record": {
		"name": "hawpey",
		"hostname": "something", // An example
		"pid": 50346, // Another example
		"level": 30
		"v": 0,
		"time": "2012-06-19T21:34:19.906Z" // Example
		"area": "charts",
		"output": "Name", // Example
		"value": 10 // Another example
		"msg": ""
	}
}
```

For consistency with logging, Bunyan is used for generating charts. The only relevant fields are `output` and `value`, which describe the data point.

#### Bad Requests (device → master)
```javascript
{
	"type": "bad",
	"code": 400, // An example
	"description": "There has been an error", // Another example
}
```

When there is an error processing a request sent by the master, the device should send a Bad Request message.

`code` represents the equivalent HTTP status code of the error.

`description` is a short description of why the request could not be processed.

The RESTful API
---------------
The API is simply mounted at path `/` on port `2000`.

Unless specified, POST requests are sent with a content-type of `application/json`.

Note: the comments in the response will not be returned in the response and are rather for documentation purposes. Similarly, comments in the form body are for documentation and should not be sent.

### The root
HTTP: Request: `GET /`
###### Response
Returns the contents of this document in HTML. If you are writing your own implementation of a Hawpey server this is completely optional. It's just so `/` points *somewhere*.

### Variables

#### Get all variables
HTTP Request: `GET /variables`
###### Response
```javascript
{
	"example": { // The name of the variable
		"value": "val", // The current value of the variable
		"validator": ".*" // regex string specifying how to validate the variable
	},
	"example2": { // Again, the name
		"value": "val", // Values are always strings
		"validator": "\\d+"
	}
}
```

#### Get a specific variable
HTTP Request: `GET /variables/<name>`
###### Response
```javascript
{
	"value": "val",
	"validator": ".*"
}
```

#### Modify a variable
HTTP Request: `PUT /variables/<name>`
###### Form body
```javascript
{
	"value": "val"
}
```
###### Response
A status code of 204 is returned. If the variable does not pass `validator`, a 400 error code is returned.

### Controls

#### Get all controls
HTTP Request: `GET /controls`
###### Response
```javascript
{
	"example": { // The name of the control
		"type": "boolean" // For on-off switch
	},
	"example2": { // Again, the name
		"type": "number", // For slider
		"min": 0, // Minimum value of slider
		"max": 100 // Maximum value of slider
	}
}
```

#### Get a specific control
HTTP Request: `GET /controls/<name>`
###### Response
```javascript
{
	"type": "boolean" // See above
}
```

#### Modify a control
HTTP Request: `PUT /controls/<name>`
###### Form body
```javascript
{
	"value": true // Either number or boolean depending on control's type
}
```
###### Response
```javascript
{
	"value": true // The new value of the control's output.
}
```
It should *not* be assumed that the new value will be the same as the value that was sent.

The new value is also sent out through the Websocket. It is only additionally sent through the HTTP response for clients only using the RESTful API.

### Outputs

#### Get all outputs
HTTP Request: `GET /outputs`
###### Response
See the websocket documentation.

#### Get a specific output
HTTP Request: `GET /outputs/<name>`
###### Response
See the websocket documentation.


### Program

#### Get the program
HTTP Request: `GET /program`
###### Response
The program, with mime type `text/plain`

#### Modify the program
HTTP Request: `PUT /program`
###### Form body
Should be sent with mime type `text/plain`, with the program sent as the form body.
###### Response
None

### Dependencies

#### Get all npm packages not mentioned in `package.json`
HTTP Request: `GET /dependencies`
###### Response
```javascript
{
	"library": "1.0.4",
	"another library": "0.8.1"
}
```
#### Install a package
HTTP Request: `POST /dependencies`
###### Response
Just a `201` status code

### Format

#### Get the current contents of `format.json` (formatting)
HTTP Request: `GET /format`
###### Response
The contents of `format.json`

#### Overwrite `format.json` (formatting) with new data
HTTP Request: `PUT /format`
###### Form body
Should be sent with mime type `text/plain`, with the program sent as the form body.
###### Response
None

### Log

#### Get all recent log messages
HTTP Request: `GET /log`
###### Response
The contents of `log/device.log`

### Charts

#### Get all plotted outputs
HTTP Request: `GET /charted`
###### Response
An array of every output that appears in `log/charts.log`

#### Get all plotted points
HTTP Request: `GET /charts`
###### Response
The contents of `log/charts.log`

#### Get all plotted points for an output
HTTP Request: `GET /charts/<output>`
###### Response
The contents of `log/charts.log` where the output matches the one specified in the URL

### Timers

### Get all timers and their interval times
HTTP Request: `GET /timers`
###### Response
```javascript
{
	"timer": 1000, // A timer named timer 1 that is executed every 1000 ms
	"timer 2": 5000
}
```
#### Trigger a timer
HTTP Request: `GET /timers/<name>`
###### Response
Just a `204` status code

## Multiple devices on one IP address
If there are multiple peripherals attached to one physical device that, for ease of use, should be labeled as multiple devices, the first device's webserver should be located at port `2001` and the rest should be at ports increasing from `2001` (e.i. `2002`, `2003`, `2004`... ). The device at port.

At port `2000`, there should be a webserver that when a `GET` http request is sent to `/ports`, should return an array of the ports in JSON format such as the following:
```javascript
[2001, 2002, 2003]
```

### Triggers

#### Get all triggers for the device
HTTP Request: `GET /triggers`
###### Response
```javascript
[
	{
		"id": "8228139e-c512-45eb-9afd-8b4e48c955c2",
		"conditions": [
			{
				"type": "logic", // Triggers when output's value matches something
				"output": "\"hostname:2000\".output", // Name of output with address and . before
				"condition": "== 10"
			},
			{
				"type": "logic",
				"output": "\"hostname:2000\".output",
				"condition": "< 10" // Can also be less than or greater than or equal to, etc.
			},
			{
				"type": "change", // When an output's value changes
				"output": "\"hostname:2000\".output"
			} /*, TODO
			{
				"type": "expression", // Triggers if an expression is truthy
				"names": ["output"], // Names of outputs involved in this expressoin
				"expression": "output('hostname:2000', 'output') == 10" // Outputs referenced by output(address, name)
			},
				"type": "expression", // Triggers if an expression is truthy
				"names": ["output"], // Names of outputs involved in this expressoin
				"expression": "output('hostname:2000', 'output') > prev('hostname:2000', 'output')" // Can also reference previous value of output
			} */
		],
		"results": [
			{
				"type": "control",
				"control": "\"hostname:2000\".a control", // Name of control
				"value": true
			},
			{
				"type": "expression",
				"expression": "control('hostname:2000', 'control', output(' hostname:2000', 'output'))" // Controls set by control(address, name, value)
			}
		]
	}
]
```

As Hawpey is still in development, currently only one logic trigger condition and only trigger results of type `control` are currently supported.